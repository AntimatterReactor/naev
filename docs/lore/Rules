# A few helpful tips about the Rules file:
#
# * The string given to #compile and #route are matching patterns for
#   identifiers--not for paths. Therefore, you can’t match on extension.
#
# * The order of rules is important: for each item, only the first matching
#   rule is applied.
#
# * Item identifiers start and end with a slash (e.g. “/about/” for the file
#   “content/about.html”). To select all children, grandchildren, … of an
#   item, use the pattern “/about/*/”; “/about/*” will also select the parent,
#   because “*” matches zero or more characters.

# ignore everything starting with underscore
ignore '/**/_*'

preprocess do
   # create name -> item mappings
   nametospob = {}
   @items.find_all('/spob/*.md').each do |s|
      s[:name] = s[:spob][:"+@name"]
      nametospob[s[:name]] = s
   end
   nametossys = {}
   @items.find_all("/ssys/*.md").each do |s|
      s[:name] = s[:ssys][:"+@name"]
      nametossys[s[:name]] = s
   end

   # Mappings from spob to system and system to array of spobs.
   spobssys = {}
   ssysspob = {}

   # Process systems
   @items.find_all('/ssys/*.md').each do |s|
      # Core attributes
      s[:id] =  Base64.encode64( s[:name] )

      # Map spobs to systems
      spb = s[:ssys][:spobs]
      if not spb.nil? and not spb[:spob].nil?
         if ssysspob[ s[:name] ].nil?
            ssysspob[ s[:name] ] = []
         end
         Array(spb[:spob]).each do |p|
            spobssys[p] = s[:name]
            ssysspob[ s[:name] ].push( nametospob[spobssys[p]] )
         end
         s[:spobs] = ssysspob[ s[:name] ]
      else
         s[:spobs] = []
      end
   end

   @items.find_all('/spob/*.md').each do |s|
      # Core attributes
      s[:id] =  Base64.encode64( s[:name] )

      # Set some other atrtibutes
      if not s[:spob][:general][:description].nil? then
         s[:description] = s[:spob][:general][:description]
      end
      if not s[:spob][:general][:bar].nil? then
         s[:bar] = s[:spob][:general][:bar]
      end
      if not s[:spob][:general][:population].nil? then
         s[:population] = s[:spob][:general][:population].to_f.to_i.to_s
      else
         s[:population] = 0
      end
      if not s[:spob][:presence].nil? and not s[:spob][:presence][:faction].nil?
         s[:faction] = s[:spob][:presence][:faction]
      else
         s[:faction] = "Factionless"
      end
      s[:spobclass] = s[:spob][:general][:class]
      if not s[:spob][:general][:services].nil?
         s[:services] = s[:spob][:general][:services].keys
      else
         s[:services] = []
      end
      if not s[:spob][:tags].nil?
         s[:tags] = Array(s[:spob][:tags][:tag])
      else
         s[:tags] = []
      end

      # See if in system
      if not spobssys[ s[:name] ].nil? then
         s[:ssys] = nametossys[ spobssys[ s[:name] ] ]

         # Get neighbours
         s[:neighbours] = []
         s[:ssys][:spobs].each do |n|
            if n!=s[:name]
               s[:neighbours].push(n)
            end
         end
      else
         s[:tags].push( "nosystem" )
      end
   end
end

# some special files
compile '/sitemap.rb' do
   filter :erb
   write '/sitemap.xml'
end
compile '/robots.txt' do
   filter :erb
   write '/robots.txt'
end

compile '/spob/*.xml' do
   filter :x
end

# favoicon
[16, 32, 64, 128, 180, 196].each do |s|
   compile '/favicon.png', rep: "s#{s.to_s}" do
      filter :thumbnailize, :width => s, :height => s
      write "/favicon-#{s.to_s}.png"
   end
end
compile '/favicon.png', rep: :ico do
   filter :thumbnailize, :width => 48, :height => 48, :filetype => 'ico'
   write '/favicon.ico'
end

compile '/**/*.md' do
  if item['hidden'].nil?
    filter :erb

    # Markdown
    filter :kramdown

    # Standard procesing
    layout '/default.html'
    filter :relativize_paths, :type => :css
    filter :relativize_paths, :type => :html
    filter :external, exec: 'tidy', options: %w(--quiet yes --indent auto --indent-spaces 2 --wrap 100 --tidy-mark no --char-encoding utf8 --add-meta-charset yes --drop-empty-elements no --warn-proprietary-attributes no)

    basename = (item.identifier=='/index.md') ? '' : item.identifier.without_ext
    write basename+'/index.html'
  end
end

# Javascript and friends
compile '/**/*.js' do
   filter :concat_js
   filter :uglify_js, :comments => :none
   write ext: 'js'
end

# CSS and friends
compile '**/*.{css,scss}' do
   filter :erb
   filter :dart_sass, syntax: :scss if item[:extension] == 'scss'
   filter :rainpress
   write ext: 'css'
end

# Other objects
compile '/**/*' do
   write item.identifier.to_s
end

layout '/**/*', :erb
